// DEPRECATED: This hook has been replaced by useSingleConversation
// 
// The localStorage-only approach caused chat history to be lost and
// created a split system where modal chats and main page chats were
// stored separately. 
//
// All conversation handling now uses useSingleConversation which:
// - Stores conversations in the Supabase database for persistence
// - Maintains localStorage backup for offline scenarios  
// - Provides connection monitoring and retry logic
// - Supports manual backup/restore functionality
//
// This file is kept for reference only and should not be used.

import { useState, useEffect } from 'react';
import { useAuth } from './useAuth';
import { conversationMemory } from '@/utils/conversationMemory';

export interface Message {
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  audioEnabled?: boolean;
  imageUrl?: string;
  conversationMemory?: string;
}

const MAX_MESSAGES = 50; // Keep last 50 messages max

export const useLocalStorageConversation = (conversationType: string = 'food') => {
  const [messages, setMessages] = useState<Message[]>([]);
  const [loading, setLoading] = useState(false);
  const { user } = useAuth();

  // Get storage key for this conversation type
  const getStorageKey = () => {
    if (!user?.id) return null;
    return `conversation_${conversationType}_${user.id}`;
  };

  // Load conversation memory
  const loadConversationMemory = () => {
    if (!user?.id) return;
    const saved = localStorage.getItem(`conversation_memory_${user.id}`);
    if (saved) {
      conversationMemory.import(saved);
    }
  };

  // Save conversation memory
  const saveConversationMemory = () => {
    if (user?.id) {
      localStorage.setItem(`conversation_memory_${user.id}`, conversationMemory.export());
    }
  };

  // Load messages from localStorage
  const loadConversation = async () => {
    const storageKey = getStorageKey();
    if (!storageKey) {
      setMessages([]);
      return;
    }

    setLoading(true);
    
    try {
      // Initialize conversation memory
      await conversationMemory.initializeWithUser(user!.id);
      loadConversationMemory();

      const stored = localStorage.getItem(storageKey);
      if (stored) {
        const storedMessages = JSON.parse(stored);
        const transformedMessages = storedMessages.map((msg: any) => ({
          ...msg,
          timestamp: new Date(msg.timestamp)
        }));
        
        console.log('DEBUG: Loaded', transformedMessages.length, 'messages from localStorage');
        setMessages(transformedMessages);
      } else {
        console.log('DEBUG: No stored conversation, starting fresh');
        // Add greeting message for food assistant
        const greetingMessage: Message = {
          role: 'assistant',
          content: 'Hi! I can help you add, edit, or delete foods from your log. Just tell me what you\'d like to do - like "add chicken breast 200g" or "edit my last meal".',
          timestamp: new Date()
        };
        
        const newMessages = [greetingMessage];
        setMessages(newMessages);
        saveMessages(newMessages);
        
        // Initialize conversation memory
        conversationMemory.updateConversationState({ 
          currentTopic: 'food_tracking',
          isProcessingFood: false,
          awaitingClarification: false,
          sessionType: 'food_tracking'
        });
      }
    } catch (error) {
      console.error('Error loading conversation:', error);
    } finally {
      setLoading(false);
    }
  };

  // Save messages to localStorage
  const saveMessages = (messagesToSave: Message[]) => {
    const storageKey = getStorageKey();
    if (!storageKey) return;

    // Keep only the last MAX_MESSAGES
    const trimmedMessages = messagesToSave.slice(-MAX_MESSAGES);
    
    // Serialize messages with timestamps as ISO strings
    const messagesForStorage = trimmedMessages.map(msg => ({
      ...msg,
      timestamp: msg.timestamp.toISOString()
    }));

    localStorage.setItem(storageKey, JSON.stringify(messagesForStorage));
    console.log('DEBUG: Saved', messagesForStorage.length, 'messages to localStorage');
  };

  // Add message to conversation
  const addMessage = async (message: Message) => {
    if (!user) return false;

    console.log('DEBUG: addMessage called with:', message);

    try {
      // Check if this is a food clarification before processing
      const foodClarification = conversationMemory.detectFoodClarification(message.content);
      if (foodClarification.isModification) {
        console.log('DEBUG: Detected food clarification:', foodClarification);
        // Add memory context to the message
        message.conversationMemory = await conversationMemory.getContextForAI();
        conversationMemory.updateConversationState({ 
          awaitingClarification: false,
          isProcessingFood: true 
        });
      }

      // Update local state and save to localStorage
      const updatedMessages = [...messages, message];
      setMessages(updatedMessages);
      saveMessages(updatedMessages);

      // Save conversation memory
      saveConversationMemory();
      await conversationMemory.saveCrossSessionLearnings();

      return true;
    } catch (error) {
      console.error('Error adding message:', error);
      return false;
    }
  };

  // Clear conversation
  const clearConversation = async () => {
    const storageKey = getStorageKey();
    if (storageKey) {
      localStorage.removeItem(storageKey);
    }
    setMessages([]);
    
    // Reset conversation memory
    conversationMemory.updateConversationState({ 
      currentTopic: 'food_tracking',
      isProcessingFood: false,
      awaitingClarification: false,
      sessionType: 'food_tracking'
    });
  };

  // Archive conversation (for compatibility - just clears it)
  const archiveConversation = async () => {
    await clearConversation();
  };

  // Load conversation when user changes
  useEffect(() => {
    if (user) {
      loadConversation();
    } else {
      setMessages([]);
    }
  }, [user?.id]);

  // Enhanced methods for working with conversation memory
  const addFoodAction = (userMessage: string, foods: any[], type: 'add' | 'modify' | 'delete' = 'add') => {
    conversationMemory.addFoodAction(userMessage, foods, type);
    saveConversationMemory();
  };

  const updateConversationState = (updates: any) => {
    conversationMemory.updateConversationState(updates);
    saveConversationMemory();
  };

  const getConversationContext = () => {
    return conversationMemory.getContext();
  };

  return {
    messages,
    loading,
    addMessage,
    archiveConversation,
    clearConversation,
    loadConversation,
    // Enhanced memory methods
    addFoodAction,
    updateConversationState,
    getConversationContext,
    conversationMemory: conversationMemory.getContextForAI()
  };
};
